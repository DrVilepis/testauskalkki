<<<<<<< HEAD
use crate::basic::{factorial, len, sum, divide, as_bigint};
use num::FromPrimitive;
use num::rational::BigRational;
=======
use num::FromPrimitive;
>>>>>>> 68c53aa (Made math work,ish)

use crate::basic::{divide, factorial, len, sum};

pub fn npr(num1: f64, num2: f64) -> f64 {
    divide(factorial(num1.clone()), factorial(num1 - num2))
}

pub fn ncr(num1: f64, num2: f64) -> f64 {
    divide(
        factorial(num1.clone()),
        factorial(num2.clone()) * factorial(num1 - num2),
    )
}

pub fn average(nums: Vec<f64>) -> f64 {
    divide(sum(nums.clone()), f64::from_usize(len(nums)).unwrap())
}

<<<<<<< HEAD
pub fn median(nums: Vec<BigRational>) -> BigRational {
    let mut nums = nums;
    nums.sort();
    let l = nums.len();
    if l%2 != 0 {
        nums[(l/2)-1].clone()
    } else {
        divide(nums[(l/2)-1].clone()+nums[l/2].clone(), as_bigint(2))
    }
}

pub fn mode(nums: Vec<BigRational>) -> BigRational {
    let mut nums = nums;
    nums.sort();
    let mut cur = 1;
    let mut prev = &nums[0];
    let mut max = 1;
    let mut maxn = &nums[0];
    for e in nums[1..].iter() {
        if *e == *prev {
            cur += 1;
            if cur > max {
                maxn = e;
                max = cur;
            }
            continue;
        }
        prev = e;
        cur = 1;
    }
    maxn.to_owned()
=======
pub fn median(_nums: Vec<f64>) -> f64 {
    todo!();
>>>>>>> 68c53aa (Made math work,ish)
}
